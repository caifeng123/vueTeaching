### 2、shallowReactive

> 在 1 中实现的 reactive 实际上就是浅代理响应，因此需要实现深响应

#### 深、浅响应区别

比如当调用 `obj.b.push(3)` 时，实际上对于 `obj.b` 指向索引没有变化因此不会去发生响应。

对于正常逻辑（深响应）来说，肯定需要在 push 后也触发当前的 effect 函数集。

#### 问题

实际上问题出在应当在取值 `get` 时的 track 仅仅收集了当前的 key。

而我们需要判断取到的值类型，若为对象，则需要继续调用 reactive 包裹。此时就能进行追踪下方的子对象的变化了(包裹后成为响应式)

#### 改动点

**get**

-   代理取值函数 `obj.a`
-   若访问的是 `obj.raw` 则直接返回原对象 即 `{a: 1, b: [1, 2]}` ，不调用 `track` 向存储桶中添加追踪当前的 effect 函数
-   使用 `Reflect.get` 取值前进行 `track` 追踪原对象的 `key`，当 `obj.a` 变化时，会自动调用当前依赖集合。

-   <span style="color:green">+ 判断当前需要深响应还是浅响应，浅响应直接返回，深响应则需要将值变为响应式【在返回取到的值前进行判断类型，若为复杂类型则用 reactive 包裹后返回】</span>
